\doxysection{CRC\+\_\+\+CHECKSUM.\+h File Reference}
\label{_c_r_c___c_h_e_c_k_s_u_m_8h}\index{CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}}
{\ttfamily \#include $<$stdint.\+h$>$}\newline
Include dependency graph for CRC\+\_\+\+CHECKSUM.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ CRC32\+\_\+\+POLYNOMIAL}~0x\+EDB88320\+UL
\item 
\#define \textbf{ CRC32\+\_\+\+INITIAL\+\_\+\+VALUE}~0x\+FFFFFFFFUL
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \textbf{ calculate\+\_\+crc32} (uint32\+\_\+t current\+\_\+crc, const uint8\+\_\+t $\ast$data, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Updates a running CRC32 checksum based on a block of data. The CRC32 algorithm used is the standard IEEE 802.\+3 (used in Gzip and Zlib). \end{DoxyCompactList}\end{DoxyCompactItemize}


\label{doc-define-members}
\doxysubsection{Macro Definition Documentation}
\index{CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}!CRC32\_INITIAL\_VALUE@{CRC32\_INITIAL\_VALUE}}
\index{CRC32\_INITIAL\_VALUE@{CRC32\_INITIAL\_VALUE}!CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}}
\doxysubsubsection{CRC32\_INITIAL\_VALUE}
{\footnotesize\ttfamily \label{_c_r_c___c_h_e_c_k_s_u_m_8h_a8948ca1a7705abf34d9732f06b2c4e45} 
\#define CRC32\+\_\+\+INITIAL\+\_\+\+VALUE~0x\+FFFFFFFFUL}

\index{CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}!CRC32\_POLYNOMIAL@{CRC32\_POLYNOMIAL}}
\index{CRC32\_POLYNOMIAL@{CRC32\_POLYNOMIAL}!CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}}
\doxysubsubsection{CRC32\_POLYNOMIAL}
{\footnotesize\ttfamily \label{_c_r_c___c_h_e_c_k_s_u_m_8h_a32104fd66e8bf60867719c6b6c877b4b} 
\#define CRC32\+\_\+\+POLYNOMIAL~0x\+EDB88320\+UL}



\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}!calculate\_crc32@{calculate\_crc32}}
\index{calculate\_crc32@{calculate\_crc32}!CRC\_CHECKSUM.h@{CRC\_CHECKSUM.h}}
\doxysubsubsection{calculate\_crc32()}
{\footnotesize\ttfamily \label{_c_r_c___c_h_e_c_k_s_u_m_8h_a949564d32e176c6849b5ccc68c4947f3} 
uint32\+\_\+t calculate\+\_\+crc32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{current\+\_\+crc}{, }\item[{const uint8\+\_\+t $\ast$}]{data}{, }\item[{size\+\_\+t}]{length}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [extern]}}



Updates a running CRC32 checksum based on a block of data. The CRC32 algorithm used is the standard IEEE 802.\+3 (used in Gzip and Zlib). 


\begin{DoxyParams}{Parameters}
{\em current\+\_\+crc} & The current running CRC value (should be 0x\+FFFFFFFF for the start). \\
\hline
{\em data} & Pointer to the buffer containing the data chunk. \\
\hline
{\em length} & The number of bytes in the data chunk. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t The updated CRC value.
\end{DoxyReturn}
Updates a running CRC32 checksum based on a block of data. The CRC32 algorithm used is the standard IEEE 802.\+3 (used in Gzip and Zlib).


\begin{DoxyItemize}
\item 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+crc} & The current running CRC value (initial value 0x\+FFFFFFFF). \\
\hline
{\em data} & Pointer to the buffer containing the data chunk. \\
\hline
{\em length} & The number of bytes in the data chunk. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t The updated CRC value. 
\end{DoxyReturn}

\end{DoxyItemize}